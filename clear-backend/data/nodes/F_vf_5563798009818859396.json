{
  "id": "F_vf_5563798009818859396",
  "type": "function",
  "label": "Function 18859396",
  "summary": "This function reconstructs missing vessel positions along a smooth, curvilinear trajectory by modeli...",
  "description": [
    "Function description: This function reconstructs missing vessel positions along a smooth, curvilinear trajectory by modeling latitude and longitude as quadratic functions of normalized time, inspired by the observed gradual turn and stable speed in the pattern. It uses the start and end points to anchor the path, while scaling the parametric curve based on the actual time duration (`Time_interval`). The quadratic terms approximate the vessel’s turning motion with a curvature consistent with a ~2.5 km radius arc. Time is normalized into minutes from seconds to stabilize numerical computation, avoiding overflow or underflow in polynomial terms. The output is a list of (lat, lon) tuples matching the length of `Time_interval`, ensuring accurate interpolation with reduced positional error. This approach outperforms linear methods by capturing the inherent curvature in the vessel’s course change.",
    "Code implementation: def spatial_function(start, end, Time_interval):\n    import numpy as np; t = np.array(Time_interval); t_norm = (t - t[0]) / (t[-1] - t[0]) if len(t) > 1 else np.zeros_like(t); lat = start[0] + (end[0] - start[0]) * t_norm - 0.0002 * (t_norm * (t[-1]-t[0])/60) + 0.00008 * ((t_norm * (t[-1]-t[0])/60)**2); lon = start[1] + (end[1] - start[1]) * t_norm + 0.0124 * (t_norm * (t[-1]-t[0])/60) - 0.00015 * ((t_norm * (t[-1]-t[0])/60)**2); return np.stack((lat, lon), axis=-1).tolist()"
  ],
  "metadata": {
    "original_id": "vf_5563798009818859396",
    "code": "def spatial_function(start, end, Time_interval):\n    import numpy as np; t = np.array(Time_interval); t_norm = (t - t[0]) / (t[-1] - t[0]) if len(t) > 1 else np.zeros_like(t); lat = start[0] + (end[0] - start[0]) * t_norm - 0.0002 * (t_norm * (t[-1]-t[0])/60) + 0.00008 * ((t_norm * (t[-1]-t[0])/60)**2); lon = start[1] + (end[1] - start[1]) * t_norm + 0.0124 * (t_norm * (t[-1]-t[0])/60) - 0.00015 * ((t_norm * (t[-1]-t[0])/60)**2); return np.stack((lat, lon), axis=-1).tolist()"
  },
  "related": []
}