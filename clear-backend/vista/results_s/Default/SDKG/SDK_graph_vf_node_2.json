{
  "SDK_graph_vf_node": {
    "vf_7300892871073606864": {
      "description": "This function reconstructs missing vessel positions using linear interpolation along the great-circle path between the known start and end points. Given the trajectory's stable speed, near-constant northbound course, and minimal lateral deviation, a linear spatiotemporal interpolation is both numerically stable and physically meaningful. The function normalizes each time step in `Time_interval` relative to the total duration, clamps the interpolation factor to [0, 1] to avoid extrapolation errors, and computes latitude and longitude proportionally. This ensures smooth, monotonic progression from `start` to `end`, preserving the observed meridional movement pattern while minimizing positional error.",
      "code": "def spatial_function(start, end, Time_interval):\n    lat_start, lon_start = start\n    lat_end, lon_end = end\n    t_start = Time_interval[0]\n    t_end = Time_interval[-1]\n    total_duration = t_end - t_start if t_end != t_start else 1e-6\n    points = []\n    for dt in Time_interval:\n        t = (dt - t_start) / total_duration\n        t = max(0.0, min(1.0, t))\n        lat = lat_start + t * (lat_end - lat_start)\n        lon = lon_start + t * (lon_end - lon_start)\n        points.append((lat, lon))\n    return points"
    },
    "vf_-4299736627238634525": {
      "description": "This function reconstructs missing vessel positions by assuming a great-circle path between the known start and end points, using linear interpolation in 3D Cartesian space for geometric accuracy. It converts geographic coordinates to Earth-centered Cartesian coordinates, interpolates based on normalized time intervals, and converts back to latitude and longitude. The method respects the vessel\u2019s observed stable speed and heading patterns, producing smooth, physically plausible trajectory points consistent with a vessel proceeding along a fixed route with minor course adjustments.",
      "code": "def spatial_function(start, end, Time_interval): \n    from math import sin, cos, atan2, radians, degrees, sqrt\n    def geo_to_cart(lat, lon):\n        R = 6371000\n        lat, lon = radians(lat), radians(lon)\n        x = R * cos(lat) * cos(lon)\n        y = R * cos(lat) * sin(lon)\n        z = R * sin(lat)\n        return x, y, z\n    def cart_to_geo(x, y, z):\n        R = 6371000\n        lat = degrees(atan2(z, sqrt(x*x + y*y)))\n        lon = degrees(atan2(y, x))\n        return lat, lon\n    start_cart = geo_to_cart(*start)\n    end_cart = geo_to_cart(*end)\n    t_min, t_max = Time_interval[0], Time_interval[-1]\n    frac = [(t - t_min) / (t_max - t_min) if t_max > t_min else 0 for t in Time_interval]\n    points = []\n    for f in frac:\n        x = start_cart[0] + f * (end_cart[0] - start_cart[0])\n        y = start_cart[1] + f * (end_cart[1] - start_cart[1])\n        z = start_cart[2] + f * (end_cart[2] - start_cart[2])\n        points.append(cart_to_geo(x, y, z))\n    return points"
    },
    "vf_7019932154253854297": {
      "description": "This function reconstructs missing vessel positions using linear interpolation in geographic coordinates, adjusted for Earth's curvature via local meter-per-degree conversion. It computes intermediate latitude and longitude points along a straight-line path from `start` to `end`, proportionally distributed according to the time intervals provided in `Time_interval`. The model assumes constant velocity and direction\u2014consistent with the observed stable speed, near-northerly course, and minimal heading variation\u2014making it ideal for reconstructing a meridional trajectory where longitudinal change is negligible and latitudinal progression is nearly linear over time.",
      "code": "def spatial_function(start, end, Time_interval): \n    from math import cos, radians\n    lat1, lon1 = start\n    lat2, lon2 = end\n    total_time = Time_interval[-1] - Time_interval[0]\n    dt = [t - Time_interval[0] for t in Time_interval]\n    R = 6371000  # Earth radius in meters\n    lat_rad = radians(lat1)\n    meter_per_deg_lat = 111319.9\n    meter_per_deg_lon = 111319.9 * cos(lat_rad)\n    delta_lat_m = (lat2 - lat1) * meter_per_deg_lat\n    delta_lon_m = (lon2 - lon1) * meter_per_deg_lon\n    return [(lat1 + (delta_lat_m * (t / total_time)) / meter_per_deg_lat, lon1 + (delta_lon_m * (t / total_time)) / meter_per_deg_lon) for t in dt]"
    },
    "vf_8520070981880644409": {
      "description": "This function reconstructs missing vessel positions by computing great-circle intermediate points along a geodesic path between the known start and end positions. It uses normalized time fractions to interpolate along the trajectory, applying spherical linear interpolation (slerp) via midpoint formula for geographic accuracy. Given the vessel's stable speed, consistent northbound course, and minimal heading variation, this method preserves directional fidelity and reflects the intent of straight-line navigation under autopilot-like conditions. The output is a list of latitude-longitude tuples corresponding to each time step in Time_interval.",
      "code": "def spatial_function(start, end, Time_interval): \n    from math import radians, degrees, sin, cos, atan2, sqrt\n    def geo_midpoint(lat1, lon1, lat2, lon2, f):\n        lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n        \u0394lat = lat2 - lat1\n        \u0394lon = lon2 - lon1\n        A = sin((1-f)*\u0394lat) / sin(\u0394lat)\n        B = sin(f*\u0394lat) / sin(\u0394lat)\n        x = A * cos(lat1) * cos(lon1) + B * cos(lat2) * cos(lon2)\n        y = A * cos(lat1) * sin(lon1) + B * cos(lat2) * sin(lon2)\n        z = A * sin(lat1) + B * sin(lat2)\n        lat3 = atan2(z, sqrt(x*x + y*y))\n        lon3 = atan2(y, x)\n        return round(degrees(lat3), 6), round(degrees(lon3), 6)\n    t_min, t_max = Time_interval[0], Time_interval[-1]\n    if t_max == t_min:\n        return [end]\n    points = []\n    for dt in Time_interval:\n        f = (dt - t_min) / (t_max - t_min) if t_max != t_min else 0\n        lat = start[0] + f * (end[0] - start[0])\n        lon = start[1] + f * (end[1] - start[1])\n        if abs(end[0] - start[0]) > 1e-6 or abs(end[1] - start[1]) > 1e-6:\n            lat, lon = geo_midpoint(start[0], start[1], end[0], end[1], f)\n        points.append((round(lat, 6), round(lon, 6)))\n    return points"
    },
    "vf_545811567782420792": {
      "description": "This function reconstructs missing vessel positions using linear interpolation in geographic space, assuming a constant velocity motion between the known start and end points. Given the stable speed, near-constant heading, and minimal course oscillation around true north, the vessel's movement is well approximated by a straight-line trajectory along a meridian. The function computes interpolated latitude and longitude pairs at each time step in `Time_interval` relative to the start time, distributing position estimates proportionally across the temporal interval from start to end.",
      "code": "def spatial_function(start, end, Time_interval): return [(start[0] + (end[0] - start[0]) * t / max(Time_interval), start[1] + (end[1] - start[1]) * t / max(Time_interval)) for t in Time_interval]"
    },
    "vf_1938255083607052397": {
      "description": "This function reconstructs missing vessel positions along a great-circle path between the known start and end points, using time-proportional progression. It computes the initial bearing and central angle via the haversine formula, then interpolates along the geodesic based on normalized time intervals. The method respects Earth's curvature and is suitable for a vessel moving steadily northward with minimal course deviation, as observed in the trajectory pattern.",
      "code": "def spatial_function(start, end, Time_interval): \n    import math\n    def haversine_inverse(lat1, lon1, lat2, lon2):\n        dlat = math.radians(lat2 - lat1)\n        dlon = math.radians(lon2 - lon1)\n        a = math.sin(dlat/2)**2 + math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) * math.sin(dlon/2)**2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))\n        return c\n    def haversine_forward(lat1, lon1, bearing, distance_c):\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.asin(math.sin(lat1_rad) * math.cos(distance_c) + \n                             math.cos(lat1_rad) * math.sin(distance_c) * math.cos(bearing))\n        lon2_rad = lon1_rad + math.atan2(math.sin(bearing) * math.sin(distance_c) * math.cos(lat1_rad),\n                                         math.cos(distance_c) - math.sin(lat1_rad) * math.sin(lat2_rad))\n        return (math.degrees(lat2_rad), math.degrees(lon2_rad))\n    total_time = Time_interval[-1] - Time_interval[0]\n    if total_time == 0:\n        return [start for _ in Time_interval]\n    t_fractions = [(t - Time_interval[0]) / total_time for t in Time_interval]\n    lat1, lon1 = start\n    lat2, lon2 = end\n    central_angle = haversine_inverse(lat1, lon1, lat2, lon2)\n    azimuth = math.atan2(math.sin(math.radians(lon2) - math.radians(lon1)) * math.cos(math.radians(lat2)),\n                         math.cos(math.radians(lat1)) * math.sin(math.radians(lat2)) - \n                         math.sin(math.radians(lat1)) * math.cos(math.radians(lat2)) * math.cos(math.radians(lon2) - math.radians(lon1)))\n    return [haversine_forward(lat1, lon1, azimuth, t * central_angle) for t in t_fractions]"
    }
  }
}