{
  "SDK_graph_vf_node": {
    "vf_7300892871073606864": {
      "description": "This function reconstructs missing vessel positions using linear interpolation along the great-circle path between the known start and end points. Given the trajectory's stable speed, near-constant northbound course, and minimal lateral deviation, a linear spatiotemporal interpolation is both numerically stable and physically meaningful. The function normalizes each time step in `Time_interval` relative to the total duration, clamps the interpolation factor to [0, 1] to avoid extrapolation errors, and computes latitude and longitude proportionally. This ensures smooth, monotonic progression from `start` to `end`, preserving the observed meridional movement pattern while minimizing positional error.",
      "code": "def spatial_function(start, end, Time_interval):\n    lat_start, lon_start = start\n    lat_end, lon_end = end\n    t_start = Time_interval[0]\n    t_end = Time_interval[-1]\n    total_duration = t_end - t_start if t_end != t_start else 1e-6\n    points = []\n    for dt in Time_interval:\n        t = (dt - t_start) / total_duration\n        t = max(0.0, min(1.0, t))\n        lat = lat_start + t * (lat_end - lat_start)\n        lon = lon_start + t * (lon_end - lon_start)\n        points.append((lat, lon))\n    return points"
    },
    "vf_-4299736627238634525": {
      "description": "This function reconstructs missing vessel positions by assuming a great-circle path between the known start and end points, using linear interpolation in 3D Cartesian space for geometric accuracy. It converts geographic coordinates to Earth-centered Cartesian coordinates, interpolates based on normalized time intervals, and converts back to latitude and longitude. The method respects the vessel\u2019s observed stable speed and heading patterns, producing smooth, physically plausible trajectory points consistent with a vessel proceeding along a fixed route with minor course adjustments.",
      "code": "def spatial_function(start, end, Time_interval): \n    from math import sin, cos, atan2, radians, degrees, sqrt\n    def geo_to_cart(lat, lon):\n        R = 6371000\n        lat, lon = radians(lat), radians(lon)\n        x = R * cos(lat) * cos(lon)\n        y = R * cos(lat) * sin(lon)\n        z = R * sin(lat)\n        return x, y, z\n    def cart_to_geo(x, y, z):\n        R = 6371000\n        lat = degrees(atan2(z, sqrt(x*x + y*y)))\n        lon = degrees(atan2(y, x))\n        return lat, lon\n    start_cart = geo_to_cart(*start)\n    end_cart = geo_to_cart(*end)\n    t_min, t_max = Time_interval[0], Time_interval[-1]\n    frac = [(t - t_min) / (t_max - t_min) if t_max > t_min else 0 for t in Time_interval]\n    points = []\n    for f in frac:\n        x = start_cart[0] + f * (end_cart[0] - start_cart[0])\n        y = start_cart[1] + f * (end_cart[1] - start_cart[1])\n        z = start_cart[2] + f * (end_cart[2] - start_cart[2])\n        points.append(cart_to_geo(x, y, z))\n    return points"
    },
    "vf_8520070981880644409": {
      "description": "This function reconstructs missing vessel positions by computing great-circle intermediate points along a geodesic path between the known start and end positions. It uses normalized time fractions to interpolate along the trajectory, applying spherical linear interpolation (slerp) via midpoint formula for geographic accuracy. Given the vessel's stable speed, consistent northbound course, and minimal heading variation, this method preserves directional fidelity and reflects the intent of straight-line navigation under autopilot-like conditions. The output is a list of latitude-longitude tuples corresponding to each time step in Time_interval.",
      "code": "def spatial_function(start, end, Time_interval): \n    from math import radians, degrees, sin, cos, atan2, sqrt\n    def geo_midpoint(lat1, lon1, lat2, lon2, f):\n        lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])\n        \u0394lat = lat2 - lat1\n        \u0394lon = lon2 - lon1\n        A = sin((1-f)*\u0394lat) / sin(\u0394lat)\n        B = sin(f*\u0394lat) / sin(\u0394lat)\n        x = A * cos(lat1) * cos(lon1) + B * cos(lat2) * cos(lon2)\n        y = A * cos(lat1) * sin(lon1) + B * cos(lat2) * sin(lon2)\n        z = A * sin(lat1) + B * sin(lat2)\n        lat3 = atan2(z, sqrt(x*x + y*y))\n        lon3 = atan2(y, x)\n        return round(degrees(lat3), 6), round(degrees(lon3), 6)\n    t_min, t_max = Time_interval[0], Time_interval[-1]\n    if t_max == t_min:\n        return [end]\n    points = []\n    for dt in Time_interval:\n        f = (dt - t_min) / (t_max - t_min) if t_max != t_min else 0\n        lat = start[0] + f * (end[0] - start[0])\n        lon = start[1] + f * (end[1] - start[1])\n        if abs(end[0] - start[0]) > 1e-6 or abs(end[1] - start[1]) > 1e-6:\n            lat, lon = geo_midpoint(start[0], start[1], end[0], end[1], f)\n        points.append((round(lat, 6), round(lon, 6)))\n    return points"
    },
    "vf_545811567782420792": {
      "description": "This function reconstructs missing vessel positions using linear interpolation in geographic space, assuming a constant velocity motion between the known start and end points. Given the stable speed, near-constant heading, and minimal course oscillation around true north, the vessel's movement is well approximated by a straight-line trajectory along a meridian. The function computes interpolated latitude and longitude pairs at each time step in `Time_interval` relative to the start time, distributing position estimates proportionally across the temporal interval from start to end.",
      "code": "def spatial_function(start, end, Time_interval): return [(start[0] + (end[0] - start[0]) * t / max(Time_interval), start[1] + (end[1] - start[1]) * t / max(Time_interval)) for t in Time_interval]"
    },
    "vf_1938255083607052397": {
      "description": "This function reconstructs missing vessel positions along a great-circle path between the known start and end points, using time-proportional progression. It computes the initial bearing and central angle via the haversine formula, then interpolates along the geodesic based on normalized time intervals. The method respects Earth's curvature and is suitable for a vessel moving steadily northward with minimal course deviation, as observed in the trajectory pattern.",
      "code": "def spatial_function(start, end, Time_interval): \n    import math\n    def haversine_inverse(lat1, lon1, lat2, lon2):\n        dlat = math.radians(lat2 - lat1)\n        dlon = math.radians(lon2 - lon1)\n        a = math.sin(dlat/2)**2 + math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) * math.sin(dlon/2)**2\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))\n        return c\n    def haversine_forward(lat1, lon1, bearing, distance_c):\n        lat1_rad = math.radians(lat1)\n        lon1_rad = math.radians(lon1)\n        lat2_rad = math.asin(math.sin(lat1_rad) * math.cos(distance_c) + \n                             math.cos(lat1_rad) * math.sin(distance_c) * math.cos(bearing))\n        lon2_rad = lon1_rad + math.atan2(math.sin(bearing) * math.sin(distance_c) * math.cos(lat1_rad),\n                                         math.cos(distance_c) - math.sin(lat1_rad) * math.sin(lat2_rad))\n        return (math.degrees(lat2_rad), math.degrees(lon2_rad))\n    total_time = Time_interval[-1] - Time_interval[0]\n    if total_time == 0:\n        return [start for _ in Time_interval]\n    t_fractions = [(t - Time_interval[0]) / total_time for t in Time_interval]\n    lat1, lon1 = start\n    lat2, lon2 = end\n    central_angle = haversine_inverse(lat1, lon1, lat2, lon2)\n    azimuth = math.atan2(math.sin(math.radians(lon2) - math.radians(lon1)) * math.cos(math.radians(lat2)),\n                         math.cos(math.radians(lat1)) * math.sin(math.radians(lat2)) - \n                         math.sin(math.radians(lat1)) * math.cos(math.radians(lat2)) * math.cos(math.radians(lon2) - math.radians(lon1)))\n    return [haversine_forward(lat1, lon1, azimuth, t * central_angle) for t in t_fractions]"
    },
    "vf_-8136077885164574932": {
      "description": "This function reconstructs missing vessel positions by assuming uniform motion along a great-circle path between the start and end points. It converts geographic coordinates to Cartesian 3D space using a spherical Earth model, performs linear interpolation in Cartesian space proportional to time intervals, then converts back to latitude and longitude. This approach respects the vessel\u2019s observed stable speed and directional intent, providing a physically plausible trajectory consistent with sustained linear navigation along a fixed maritime route.",
      "code": "def spatial_function(start, end, Time_interval): \n    from math import sin, cos, atan2, radians, degrees, sqrt; \n    def geo_to_cart(lat, lon): R = 6371000; lat, lon = radians(lat), radians(lon); return R * cos(lat) * cos(lon), R * cos(lat) * sin(lon), R * sin(lat)\n    def cart_to_geo(x, y, z): R = 6371000; lat, lon = degrees(atan2(z, sqrt(x*x + y*y))), degrees(atan2(y, x)); return lat, lon\n    start_cart = geo_to_cart(*start); end_cart = geo_to_cart(*end); total_time = Time_interval[-1]; \n    return [cart_to_geo(*(start_cart[i] + (end_cart[i] - start_cart[i]) * t / total_time for i in range(3))) for t in Time_interval]"
    },
    "vf_2233287852807700801": {
      "description": "This function reconstructs missing vessel positions using linear interpolation in geographic space, weighted by time intervals. Given the start and end points around a data gap and a list of relative timestamps, it computes intermediate latitude and longitude pairs proportionally along the great-circle segment implied by temporal progression. The method assumes constant speed and steady course \u2014 consistent with the observed stable SOG, oscillating but narrow-range COG, and stable heading \u2014 making linear spatiotemporal interpolation a physically plausible and numerically stable choice for a vessel on a fixed-route intent.",
      "code": "def spatial_function(start, end, Time_interval): \n    import numpy as np; N = len(Time_interval); t = np.array(Time_interval); t0, t1 = t[0], t[-1]; frac = (t - t0) / (t1 - t0 + 1e-9); lat = start[0] + frac * (end[0] - start[0]); lon = start[1] + frac * (end[1] - start[1]); return np.stack([lat, lon], axis=-1).tolist()"
    },
    "vf_-6997057208092212406": {
      "description": "This function reconstructs missing vessel positions using great-circle navigation based on the observed stable speed and nearly constant course. It computes the initial bearing and distance between `start` and `end` using the Haversine formula, then interpolates intermediate positions along this geodesic path proportionally to time intervals. The model assumes uniform motion over ground \u2014 consistent with the trajectory's stable SOG and oscillating but narrow-range COG \u2014 making it suitable for vessels proceeding along a fixed route with minimal maneuvering. The output is a list of (latitude, longitude) tuples matching the length of `Time_interval`.",
      "code": "def spatial_function(start, end, Time_interval):  \n    import math  \n    def haversine_inverse(lat1, lon1, lat2, lon2):  \n        R = 6371e3  # Earth radius in meters  \n        phi1 = math.radians(lat1)  \n        phi2 = math.radians(lat2)  \n        dphi = math.radians(lat2 - lat1)  \n        dlambda = math.radians(lon2 - lon1)  \n        a = math.sin(dphi/2)**2 + math.cos(phi1)*math.cos(phi2)*math.sin(dlambda/2)**2  \n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))  \n        return R * c, math.degrees(math.atan2(math.sin(dlambda) * math.cos(phi2),  \n                                           math.cos(phi1) * math.sin(phi2) - math.sin(phi1) * math.cos(phi2) * math.cos(dlambda)))  \n    def haversine_direct(lat, lon, distance, bearing):  \n        R = 6371e3  \n        phi = math.radians(lat)  \n        lambda_ = math.radians(lon)  \n        theta = math.radians(bearing)  \n        phi2 = math.asin(math.sin(phi) * math.cos(distance/R) +   \n                         math.cos(phi) * math.sin(distance/R) * math.cos(theta))  \n        lambda2 = lambda_ + math.atan2(math.sin(theta) * math.sin(distance/R) * math.cos(phi),  \n                                       math.cos(distance/R) - math.sin(phi) * math.sin(phi2))  \n        return math.degrees(phi2), math.degrees(lambda2)  \n    total_time = Time_interval[-1] - Time_interval[0]  \n    if total_time <= 0:  \n        return [start] * len(Time_interval)  \n    dist, course = haversine_inverse(*start, *end)  \n    speed_mps = dist / total_time  \n    points = []  \n    for dt in Time_interval:  \n        t = dt - Time_interval[0]  \n        d = speed_mps * t  \n        lat, lon = haversine_direct(start[0], start[1], d, course)  \n        points.append((lat, lon))  \n    return points"
    },
    "vf_-837080993201169327": {
      "description": "This function reconstructs missing vessel positions using great-circle navigation based on the observed stable speed and nearly constant course over ground. It computes the initial bearing and angular distance between `start` and `end` points using the haversine formula, then interpolates intermediate positions proportionally along the spherical path according to normalized time intervals. The method respects Earth\u2019s curvature and is particularly suitable for vessels following a fixed route with minimal course deviation, as indicated by the trajectory behavior pattern. The output is a list of [latitude, longitude] pairs with shape matching the input `Time_interval`.",
      "code": "def spatial_function(start, end, Time_interval): \n    import math\n    def haversine_inverse(lat1, lon1, lat2, lon2):\n        dlat = math.radians(lat2 - lat1)\n        dlon = math.radians(lon2 - lon1)\n        a = (math.sin(dlat/2)**2 + \n             math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) * math.sin(dlon/2)**2)\n        return 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))\n    def haversine_direct(lat, lon, c, d):\n        R = 6371000  \n        c_rad = math.radians(c)\n        lat_rad = math.radians(lat)\n        d_rad = d / R\n        new_lat = math.asin(math.sin(lat_rad) * math.cos(d_rad) + \n                            math.cos(lat_rad) * math.sin(d_rad) * math.cos(c_rad))\n        y = math.sin(c_rad) * math.sin(d_rad) * math.cos(lat_rad)\n        x = math.cos(d_rad) - math.sin(lat_rad) * math.sin(new_lat)\n        new_lon = lon + math.degrees(math.atan2(y, x))\n        return math.degrees(new_lat), new_lon\n    total_dt = Time_interval[-1] - Time_interval[0]\n    if total_dt == 0:\n        return [list(start)] * len(Time_interval)\n    start_lat, start_lon = start\n    end_lat, end_lon = end\n    angular_distance = haversine_inverse(start_lat, start_lon, end_lat, end_lon)\n    course = math.degrees(math.atan2(\n        math.sin(math.radians(end_lon - start_lon)) * math.cos(math.radians(end_lat)),\n        math.cos(math.radians(start_lat)) * math.sin(math.radians(end_lat)) -\n        math.sin(math.radians(start_lat)) * math.cos(math.radians(end_lat)) * math.cos(math.radians(end_lon - start_lon))\n    ))\n    course = (course + 360) % 360\n    points = []\n    for t in Time_interval:\n        f = t / total_dt if total_dt != 0 else 0\n        f = max(0.0, min(1.0, f))\n        interp_dist = f * angular_distance\n        lat, lon = haversine_direct(start_lat, start_lon, course, interp_dist * 6371000)\n        points.append([lat, lon])\n    return points"
    },
    "vf_708100910539385052": {
      "description": "This function reconstructs intermediate vessel positions using linear interpolation along the great-circle path between the start and end points. It assumes uniform motion over time, distributing positions proportionally based on normalized time intervals. Given the trajectory's stable speed, consistent heading, and minor course oscillations, this model reflects a vessel progressing steadily along a fixed route with minimal maneuvering, making linear geographic interpolation both interpretable and appropriate.",
      "code": "def spatial_function(start, end, Time_interval): \n    from math import sin, cos, atan2, radians, degrees\n    lat1, lon1 = radians(start[0]), radians(start[1])\n    lat2, lon2 = radians(end[0]), radians(end[1])\n    total_sec = Time_interval[-1] - Time_interval[0]\n    frac = [(t - Time_interval[0]) / total_sec for t in Time_interval]\n    bearing = atan2(sin(lon2 - lon1) * cos(lat2), cos(lat1) * sin(lat2) - sin(lat1) * cos(lat2) * cos(lon2 - lon1))\n    points = []\n    for f in frac:\n        a = f\n        lat = lat1 + a * (lat2 - lat1)\n        lon = lon1 + a * (lon2 - lon1)\n        lat, lon = lat, lon\n        points.append((degrees(lat), degrees(lon)))\n    return points"
    }
  }
}