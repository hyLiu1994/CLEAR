{
  "SDK_graph_vf_node": {
    "vf_-3130087452792645394": {
      "description": "This function reconstructs missing vessel positions using linear interpolation along a straight-line trajectory, consistent with the observed behavior pattern of stable course (near 358\u00b0\u2013360\u00b0/0\u00b0), constant speed, and minimal heading variation. It assumes the vessel maintains a steady, predictable path between the known start and end points, computing intermediate latitude and longitude values at each time interval by proportionally advancing along the geodesic segment from `start` to `end`. The model leverages the strong evidence of straight-line navigation and uniform motion, making linear interpolation both accurate and interpretable.",
      "code": "def spatial_function(start, end, Time_interval): return [ (start[0] + (end[0] - start[0]) * t / Time_interval[-1], start[1] + (end[1] - start[1]) * t / Time_interval[-1]) for t in Time_interval ]"
    },
    "vf_-2116487659008371225": {
      "description": "",
      "code": "def spatial_function(start, end, Time_interval): import numpy as np; t = np.array(Time_interval); lat_start, lon_start = start; lat_end, lon_end = end; # Compute cumulative distance along the path using constant speed and time intervals dt = t[1:] - t[:-1]; total_time = t[-1]; # Assume constant speed (average of SOGs) avg_sog = 10.4; # knots, convert to degrees per second: 1 knot \u2248 0.000015783 deg/s (approximate at mid-lat) speed_deg_per_sec = avg_sog * 0.000015783; # Total distance in degrees dist_total = speed_deg_per_sec * total_time; # Use a smooth curve model: circular arc with constant curvature based on course change over time delta_cog = (np.degrees(np.arctan2(np.sin(np.radians(lat_end - lat_start)), np.cos(np.radians(lat_end - lat_start)) * np.sin(np.radians(lon_end - lon_start)))) - np.degrees(np.arctan2(np.sin(np.radians(lat_start - lat_start)), np.cos(np.radians(lat_start - lat_start)) * np.sin(np.radians(lon_start - lon_start))))); # Instead, use a more robust approach: fit a cubic Hermite spline in latitude/longitude space with consistent heading and course trends # Extract initial and final course (COG) from behavior pattern: assume linear decrease in COG from ~359.6\u00b0 to ~354.7\u00b0 over total_time initial_cog = 359.6; final_cog = 354.7; # Linearly decreasing course over time cog_t = np.linspace(initial_cog, final_cog, len(t)); # Convert course to direction vector in local tangent plane (using small-angle approximation) # Use spherical geometry: approximate displacement using great circle arc with constant curvature # Use a parametric curve: s(t) = s0 + v*t, but with turning rate d(cog)/dt = constant turning_rate = (final_cog - initial_cog) / total_time # radians per second turning_rate_rad = np.radians(turning_rate) / 3600 # per second # Model as a circular arc: integrate velocity with changing direction # Position update: dlat/dt = v * cos(cog(t)) / R, dlon/dt = v * sin(cog(t)) / (R * cos(lat)) # But for small displacements, use flat Earth approximation with average latitude avg_lat = (lat_start + lat_end) / 2; # Approximate radius of curvature in degrees R_deg = 111.111 # km per degree lat, so 1 deg \u2248 111.111 km # Convert speed to deg/sec: v_deg = avg_sog * 0.000015783 # deg/sec # Initialize output points lat_path = []; lon_path = []; # Integrate numerically using trapezoidal rule for i in range(len(t)): if i == 0: lat_path.append(lat_start); lon_path.append(lon_start); else: dt_i = t[i] - t[i-1]; # Current course at time t[i] cog_i = cog_t[i]; # Directional components in degrees per second: dx = v_deg * np.sin(np.radians(cog_i)) # eastward dy = v_deg * np.cos(np.radians(cog_i)) # northward # Adjust for latitude-dependent longitude scaling: scale = np.cos(np.radians(avg_lat)) # Average latitude correction lon_d = dx * scale; lat_d = dy; # Update position lat_path.append(lat_path[-1] + lat_d * dt_i); lon_path.append(lon_path[-1] + lon_d * dt_i); return np.column_stack((lat_path, lon_path))"
    }
  }
}